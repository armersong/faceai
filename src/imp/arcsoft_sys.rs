/* automatically generated by rust-bindgen */
pub const MNull: u32 = 0;
pub const MFalse: u32 = 0;
pub const MTrue: u32 = 1;
pub const MAX_PATH: u32 = 256;
pub const ASVL_PAF_RGB16_B5G6R5: u32 = 257;
pub const ASVL_PAF_RGB16_B5G5R5: u32 = 258;
pub const ASVL_PAF_RGB16_B4G4R4: u32 = 259;
pub const ASVL_PAF_RGB16_B5G5R5T: u32 = 260;
pub const ASVL_PAF_RGB16_R5G6B5: u32 = 261;
pub const ASVL_PAF_RGB16_R5G5B5: u32 = 262;
pub const ASVL_PAF_RGB16_R4G4B4: u32 = 263;
pub const ASVL_PAF_RGB24_B8G8R8: u32 = 513;
pub const ASVL_PAF_RGB24_B6G6R6: u32 = 514;
pub const ASVL_PAF_RGB24_B6G6R6T: u32 = 515;
pub const ASVL_PAF_RGB24_R8G8B8: u32 = 516;
pub const ASVL_PAF_RGB24_R6G6B6: u32 = 517;
pub const ASVL_PAF_RGB32_B8G8R8: u32 = 769;
pub const ASVL_PAF_RGB32_B8G8R8A8: u32 = 770;
pub const ASVL_PAF_RGB32_R8G8B8: u32 = 771;
pub const ASVL_PAF_RGB32_A8R8G8B8: u32 = 772;
pub const ASVL_PAF_RGB32_R8G8B8A8: u32 = 773;
pub const ASVL_PAF_YUV: u32 = 1025;
pub const ASVL_PAF_YVU: u32 = 1026;
pub const ASVL_PAF_UVY: u32 = 1027;
pub const ASVL_PAF_VUY: u32 = 1028;
pub const ASVL_PAF_YUYV: u32 = 1281;
pub const ASVL_PAF_YVYU: u32 = 1282;
pub const ASVL_PAF_UYVY: u32 = 1283;
pub const ASVL_PAF_VYUY: u32 = 1284;
pub const ASVL_PAF_YUYV2: u32 = 1285;
pub const ASVL_PAF_YVYU2: u32 = 1286;
pub const ASVL_PAF_UYVY2: u32 = 1287;
pub const ASVL_PAF_VYUY2: u32 = 1288;
pub const ASVL_PAF_YYUV: u32 = 1289;
pub const ASVL_PAF_I420: u32 = 1537;
pub const ASVL_PAF_I422V: u32 = 1538;
pub const ASVL_PAF_I422H: u32 = 1539;
pub const ASVL_PAF_I444: u32 = 1540;
pub const ASVL_PAF_YV12: u32 = 1541;
pub const ASVL_PAF_YV16V: u32 = 1542;
pub const ASVL_PAF_YV16H: u32 = 1543;
pub const ASVL_PAF_YV24: u32 = 1544;
pub const ASVL_PAF_GRAY: u32 = 1793;
pub const ASVL_PAF_NV12: u32 = 2049;
pub const ASVL_PAF_NV21: u32 = 2050;
pub const ASVL_PAF_LPI422H: u32 = 2051;
pub const ASVL_PAF_LPI422H2: u32 = 2052;
pub const ASVL_PAF_NV41: u32 = 2053;
pub const ASVL_PAF_NEG_UYVY: u32 = 2305;
pub const ASVL_PAF_NEG_I420: u32 = 2306;
pub const ASVL_PAF_MONO_UYVY: u32 = 2561;
pub const ASVL_PAF_MONO_I420: u32 = 2562;
pub const ASVL_PAF_P8_YUYV: u32 = 2819;
pub const ASVL_PAF_SP16UNIT: u32 = 3073;
pub const ASVL_PAF_DEPTH_U16: u32 = 3074;
pub const ASVL_PAF_RAW10_RGGB_10B: u32 = 3329;
pub const ASVL_PAF_RAW10_GRBG_10B: u32 = 3330;
pub const ASVL_PAF_RAW10_GBRG_10B: u32 = 3331;
pub const ASVL_PAF_RAW10_BGGR_10B: u32 = 3332;
pub const ASVL_PAF_RAW12_RGGB_12B: u32 = 3333;
pub const ASVL_PAF_RAW12_GRBG_12B: u32 = 3334;
pub const ASVL_PAF_RAW12_GBRG_12B: u32 = 3335;
pub const ASVL_PAF_RAW12_BGGR_12B: u32 = 3336;
pub const ASVL_PAF_RAW10_RGGB_16B: u32 = 3337;
pub const ASVL_PAF_RAW10_GRBG_16B: u32 = 3338;
pub const ASVL_PAF_RAW10_GBRG_16B: u32 = 3339;
pub const ASVL_PAF_RAW10_BGGR_16B: u32 = 3340;
pub const ASVL_PAF_RAW10_GRAY_10B: u32 = 3585;
pub const ASVL_PAF_RAW10_GRAY_16B: u32 = 3713;
pub const ASF_NONE: u32 = 0;
pub const ASF_FACE_DETECT: u32 = 1;
pub const ASF_FACERECOGNITION: u32 = 4;
pub const ASF_AGE: u32 = 8;
pub const ASF_GENDER: u32 = 16;
pub const ASF_FACE3DANGLE: u32 = 32;
pub const ASF_LIVENESS: u32 = 128;
pub const ASF_IR_LIVENESS: u32 = 1024;
pub const ASF_DETECT_MODE_VIDEO: u32 = 0;
pub const ASF_DETECT_MODE_IMAGE: u32 = 4294967295;
pub const MERR_NONE: u32 = 0;
pub const MOK: u32 = 0;
pub const MERR_FSDK_FR_ERROR_BASE: u32 = 73728;
pub const MERR_FSDK_FR_INVALID_MEMORY_INFO: u32 = 73729;
pub const MERR_FSDK_FR_INVALID_IMAGE_INFO: u32 = 73730;
pub const MERR_FSDK_FR_INVALID_FACE_INFO: u32 = 73731;
pub const MERR_FSDK_FR_NO_GPU_AVAILABLE: u32 = 73732;
pub const MERR_FSDK_FR_MISMATCHED_FEATURE_LEVEL: u32 = 73733;
pub const MERR_FSDK_FACEFEATURE_ERROR_BASE: u32 = 81920;
pub const MERR_FSDK_FACEFEATURE_UNKNOWN: u32 = 81921;
pub const MERR_FSDK_FACEFEATURE_MEMORY: u32 = 81922;
pub const MERR_FSDK_FACEFEATURE_INVALID_FORMAT: u32 = 81923;
pub const MERR_FSDK_FACEFEATURE_INVALID_PARAM: u32 = 81924;
pub const MERR_FSDK_FACEFEATURE_LOW_CONFIDENCE_LEVEL: u32 = 81925;
pub const MERR_ASF_EX_BASE: u32 = 86016;
pub const MERR_ASF_EX_FEATURE_UNSUPPORTED_ON_INIT: u32 = 86017;
pub const MERR_ASF_EX_FEATURE_UNINITED: u32 = 86018;
pub const MERR_ASF_EX_FEATURE_UNPROCESSED: u32 = 86019;
pub const MERR_ASF_EX_FEATURE_UNSUPPORTED_ON_PROCESS: u32 = 86020;
pub const MERR_ASF_EX_INVALID_IMAGE_INFO: u32 = 86021;
pub const MERR_ASF_EX_INVALID_FACE_INFO: u32 = 86022;
pub const MERR_ASF_BASE: u32 = 90112;
pub const MERR_ASF_ACTIVATION_FAIL: u32 = 90113;
pub const MERR_ASF_ALREADY_ACTIVATED: u32 = 90114;
pub const MERR_ASF_NOT_ACTIVATED: u32 = 90115;
pub const MERR_ASF_SCALE_NOT_SUPPORT: u32 = 90116;
pub const MERR_ASF_ACTIVEFILE_SDKTYPE_MISMATCH: u32 = 90117;
pub const MERR_ASF_DEVICE_MISMATCH: u32 = 90118;
pub const MERR_ASF_UNIQUE_IDENTIFIER_ILLEGAL: u32 = 90119;
pub const MERR_ASF_PARAM_NULL: u32 = 90120;
pub const MERR_ASF_LIVENESS_EXPIRED: u32 = 90121;
pub const MERR_ASF_VERSION_NOT_SUPPORT: u32 = 90122;
pub const MERR_ASF_SIGN_ERROR: u32 = 90123;
pub const MERR_ASF_DATABASE_ERROR: u32 = 90124;
pub const MERR_ASF_UNIQUE_CHECKOUT_FAIL: u32 = 90125;
pub const MERR_ASF_COLOR_SPACE_NOT_SUPPORT: u32 = 90126;
pub const MERR_ASF_IMAGE_WIDTH_HEIGHT_NOT_SUPPORT: u32 = 90127;
pub const MERR_ASF_BASE_EXTEND: u32 = 90128;
pub const MERR_ASF_READ_PHONE_STATE_DENIED: u32 = 90128;
pub const MERR_ASF_ACTIVATION_DATA_DESTROYED: u32 = 90129;
pub const MERR_ASF_SERVER_UNKNOWN_ERROR: u32 = 90130;
pub const MERR_ASF_INTERNET_DENIED: u32 = 90131;
pub const MERR_ASF_ACTIVEFILE_SDK_MISMATCH: u32 = 90132;
pub const MERR_ASF_DEVICEINFO_LESS: u32 = 90133;
pub const MERR_ASF_REQUEST_TIMEOUT: u32 = 90134;
pub const MERR_ASF_APPID_DATA_DECRYPT: u32 = 90135;
pub const MERR_ASF_APPID_APPKEY_SDK_MISMATCH: u32 = 90136;
pub const MERR_ASF_NO_REQUEST: u32 = 90137;
pub const MERR_ASF_ACTIVE_FILE_NO_EXIST: u32 = 90138;
pub const MERR_ASF_IMAGEMODE_0_HIGHER_EXT_UNSUPPORT: u32 = 90139;
pub const MERR_ASF_NETWORK_BASE: u32 = 94208;
pub const MERR_ASF_NETWORK_COULDNT_RESOLVE_HOST: u32 = 94209;
pub const MERR_ASF_NETWORK_COULDNT_CONNECT_SERVER: u32 = 94210;
pub const MERR_ASF_NETWORK_CONNECT_TIMEOUT: u32 = 94211;
pub const MERR_ASF_NETWORK_UNKNOWN_ERROR: u32 = 94212;
pub type MWChar = ::std::os::raw::c_ushort;
pub type MLong = ::std::os::raw::c_long;
pub type MFloat = f32;
pub type MDouble = f64;
pub type MByte = ::std::os::raw::c_uchar;
pub type MWord = ::std::os::raw::c_ushort;
pub type MDWord = ::std::os::raw::c_uint;
pub type MHandle = *mut ::std::os::raw::c_void;
pub type MChar = ::std::os::raw::c_char;
pub type MBool = ::std::os::raw::c_long;
pub type MVoid = ::std::os::raw::c_void;
pub type MPVoid = *mut ::std::os::raw::c_void;
pub type MPChar = *mut ::std::os::raw::c_char;
pub type MShort = ::std::os::raw::c_short;
pub type MPCChar = *const ::std::os::raw::c_char;
pub type MRESULT = MLong;
pub type MCOLORREF = MDWord;
pub type MInt8 = ::std::os::raw::c_schar;
pub type MUInt8 = ::std::os::raw::c_uchar;
pub type MInt16 = ::std::os::raw::c_short;
pub type MUInt16 = ::std::os::raw::c_ushort;
pub type MInt32 = ::std::os::raw::c_int;
pub type MUInt32 = ::std::os::raw::c_uint;
pub type MInt64 = ::std::os::raw::c_longlong;
pub type MUInt64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tag_rect {
    pub left: MInt32,
    pub top: MInt32,
    pub right: MInt32,
    pub bottom: MInt32,
}
#[test]
fn bindgen_test_layout___tag_rect() {
    assert_eq!(
        ::std::mem::size_of::<__tag_rect>(),
        16usize,
        concat!("Size of: ", stringify!(__tag_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<__tag_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(__tag_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_rect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_rect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_rect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_rect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_rect>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_rect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_rect>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_rect),
            "::",
            stringify!(bottom)
        )
    );
}
pub type MRECT = __tag_rect;
pub type PMRECT = *mut __tag_rect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tag_point {
    pub x: MInt32,
    pub y: MInt32,
}
#[test]
fn bindgen_test_layout___tag_point() {
    assert_eq!(
        ::std::mem::size_of::<__tag_point>(),
        8usize,
        concat!("Size of: ", stringify!(__tag_point))
    );
    assert_eq!(
        ::std::mem::align_of::<__tag_point>(),
        4usize,
        concat!("Alignment of ", stringify!(__tag_point))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_point>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_point>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_point),
            "::",
            stringify!(y)
        )
    );
}
pub type MPOINT = __tag_point;
pub type PMPOINT = *mut __tag_point;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tag_ASVL_OFFSCREEN {
    pub u32PixelArrayFormat: MUInt32,
    pub i32Width: MInt32,
    pub i32Height: MInt32,
    pub ppu8Plane: [*mut MUInt8; 4usize],
    pub pi32Pitch: [MInt32; 4usize],
}
#[test]
fn bindgen_test_layout___tag_ASVL_OFFSCREEN() {
    assert_eq!(
        ::std::mem::size_of::<__tag_ASVL_OFFSCREEN>(),
        64usize,
        concat!("Size of: ", stringify!(__tag_ASVL_OFFSCREEN))
    );
    assert_eq!(
        ::std::mem::align_of::<__tag_ASVL_OFFSCREEN>(),
        8usize,
        concat!("Alignment of ", stringify!(__tag_ASVL_OFFSCREEN))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__tag_ASVL_OFFSCREEN>())).u32PixelArrayFormat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_OFFSCREEN),
            "::",
            stringify!(u32PixelArrayFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_OFFSCREEN>())).i32Width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_OFFSCREEN),
            "::",
            stringify!(i32Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_OFFSCREEN>())).i32Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_OFFSCREEN),
            "::",
            stringify!(i32Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_OFFSCREEN>())).ppu8Plane as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_OFFSCREEN),
            "::",
            stringify!(ppu8Plane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_OFFSCREEN>())).pi32Pitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_OFFSCREEN),
            "::",
            stringify!(pi32Pitch)
        )
    );
}
pub type ASVLOFFSCREEN = __tag_ASVL_OFFSCREEN;
pub type LPASVLOFFSCREEN = *mut __tag_ASVL_OFFSCREEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tag_ASVL_VERSION {
    pub lCodebase: MLong,
    pub lMajor: MLong,
    pub lMinor: MLong,
    pub lBuild: MLong,
    pub Version: *const MChar,
    pub BuildDate: *const MChar,
    pub CopyRight: *const MChar,
}
#[test]
fn bindgen_test_layout___tag_ASVL_VERSION() {
    assert_eq!(
        ::std::mem::size_of::<__tag_ASVL_VERSION>(),
        56usize,
        concat!("Size of: ", stringify!(__tag_ASVL_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<__tag_ASVL_VERSION>(),
        8usize,
        concat!("Alignment of ", stringify!(__tag_ASVL_VERSION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).lCodebase as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(lCodebase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).lMajor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(lMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).lMinor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(lMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).lBuild as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(lBuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).Version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).BuildDate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(BuildDate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tag_ASVL_VERSION>())).CopyRight as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__tag_ASVL_VERSION),
            "::",
            stringify!(CopyRight)
        )
    );
}
pub type ASVL_VERSION = __tag_ASVL_VERSION;
extern "C" {
    pub fn ASVL_GetVersion() -> *const ASVL_VERSION;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_VERSION {
    pub Version: MPChar,
    pub BuildDate: MPChar,
    pub CopyRight: MPChar,
}
#[test]
fn bindgen_test_layout_ASF_VERSION() {
    assert_eq!(
        ::std::mem::size_of::<ASF_VERSION>(),
        24usize,
        concat!("Size of: ", stringify!(ASF_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_VERSION>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_VERSION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_VERSION>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_VERSION),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_VERSION>())).BuildDate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_VERSION),
            "::",
            stringify!(BuildDate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_VERSION>())).CopyRight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_VERSION),
            "::",
            stringify!(CopyRight)
        )
    );
}
pub type ASF_OrientPriority = MInt32;
pub const ArcSoftFace_OrientPriority_ASF_OP_0_ONLY: ArcSoftFace_OrientPriority = 1;
pub const ArcSoftFace_OrientPriority_ASF_OP_90_ONLY: ArcSoftFace_OrientPriority = 2;
pub const ArcSoftFace_OrientPriority_ASF_OP_270_ONLY: ArcSoftFace_OrientPriority = 3;
pub const ArcSoftFace_OrientPriority_ASF_OP_180_ONLY: ArcSoftFace_OrientPriority = 4;
pub const ArcSoftFace_OrientPriority_ASF_OP_0_HIGHER_EXT: ArcSoftFace_OrientPriority = 5;
pub type ArcSoftFace_OrientPriority = u32;
pub type ASF_OrientCode = MInt32;
pub const ArcSoftFace_OrientCode_ASF_OC_0: ArcSoftFace_OrientCode = 1;
pub const ArcSoftFace_OrientCode_ASF_OC_90: ArcSoftFace_OrientCode = 2;
pub const ArcSoftFace_OrientCode_ASF_OC_270: ArcSoftFace_OrientCode = 3;
pub const ArcSoftFace_OrientCode_ASF_OC_180: ArcSoftFace_OrientCode = 4;
pub const ArcSoftFace_OrientCode_ASF_OC_30: ArcSoftFace_OrientCode = 5;
pub const ArcSoftFace_OrientCode_ASF_OC_60: ArcSoftFace_OrientCode = 6;
pub const ArcSoftFace_OrientCode_ASF_OC_120: ArcSoftFace_OrientCode = 7;
pub const ArcSoftFace_OrientCode_ASF_OC_150: ArcSoftFace_OrientCode = 8;
pub const ArcSoftFace_OrientCode_ASF_OC_210: ArcSoftFace_OrientCode = 9;
pub const ArcSoftFace_OrientCode_ASF_OC_240: ArcSoftFace_OrientCode = 10;
pub const ArcSoftFace_OrientCode_ASF_OC_300: ArcSoftFace_OrientCode = 11;
pub const ArcSoftFace_OrientCode_ASF_OC_330: ArcSoftFace_OrientCode = 12;
pub type ArcSoftFace_OrientCode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_SingleFaceInfo {
    pub faceRect: MRECT,
    pub faceOrient: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_SingleFaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_SingleFaceInfo>(),
        20usize,
        concat!("Size of: ", stringify!(ASF_SingleFaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_SingleFaceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ASF_SingleFaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_SingleFaceInfo>())).faceRect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_SingleFaceInfo),
            "::",
            stringify!(faceRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_SingleFaceInfo>())).faceOrient as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_SingleFaceInfo),
            "::",
            stringify!(faceOrient)
        )
    );
}
pub type LPASF_SingleFaceInfo = *mut ASF_SingleFaceInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_MultiFaceInfo {
    pub faceRect: *mut MRECT,
    pub faceOrient: *mut MInt32,
    pub faceNum: MInt32,
    pub faceID: *mut MInt32,
}
#[test]
fn bindgen_test_layout_ASF_MultiFaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_MultiFaceInfo>(),
        32usize,
        concat!("Size of: ", stringify!(ASF_MultiFaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_MultiFaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_MultiFaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_MultiFaceInfo>())).faceRect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_MultiFaceInfo),
            "::",
            stringify!(faceRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_MultiFaceInfo>())).faceOrient as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_MultiFaceInfo),
            "::",
            stringify!(faceOrient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_MultiFaceInfo>())).faceNum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_MultiFaceInfo),
            "::",
            stringify!(faceNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_MultiFaceInfo>())).faceID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_MultiFaceInfo),
            "::",
            stringify!(faceID)
        )
    );
}
pub type LPASF_MultiFaceInfo = *mut ASF_MultiFaceInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_ActiveFileInfo {
    pub startTime: MPChar,
    pub endTime: MPChar,
    pub platform: MPChar,
    pub sdkType: MPChar,
    pub appId: MPChar,
    pub sdkKey: MPChar,
    pub sdkVersion: MPChar,
    pub fileVersion: MPChar,
}
#[test]
fn bindgen_test_layout_ASF_ActiveFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_ActiveFileInfo>(),
        64usize,
        concat!("Size of: ", stringify!(ASF_ActiveFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_ActiveFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_ActiveFileInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).startTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).endTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(endTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).platform as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).sdkType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(sdkType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).appId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(appId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).sdkKey as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(sdkKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).sdkVersion as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(sdkVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_ActiveFileInfo>())).fileVersion as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_ActiveFileInfo),
            "::",
            stringify!(fileVersion)
        )
    );
}
pub type LPASF_ActiveFileInfo = *mut ASF_ActiveFileInfo;
extern "C" {
    /// 获取激活文件信息接口
    pub fn ASFGetActiveFileInfo(activeFileInfo: LPASF_ActiveFileInfo) -> MRESULT;
}
extern "C" {
    /// 激活接口
    pub fn ASFOnlineActivation(AppId: MPChar, SDKKey: MPChar) -> MRESULT;
}
extern "C" {
    /// 激活接口，该接口与ASFOnlineActivation接口功能一致，推荐使用ASFOnlineActivation接口
    pub fn ASFActivation(AppId: MPChar, SDKKey: MPChar) -> MRESULT;
}
extern "C" {
    /// 初始化引擎
    pub fn ASFInitEngine(
        detectMode: MUInt32,
        detectFaceOrientPriority: ASF_OrientPriority,
        detectFaceScaleVal: MInt32,
        detectFaceMaxNum: MInt32,
        combinedMask: MInt32,
        hEngine: *mut MHandle,
    ) -> MRESULT;
}
extern "C" {
    /// 人脸检测,目前不支持IR图像数据检测
    pub fn ASFDetectFaces(
        hEngine: MHandle,
        width: MInt32,
        height: MInt32,
        format: MInt32,
        imgData: *mut MUInt8,
        detectedFaces: LPASF_MultiFaceInfo,
    ) -> MRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_LivenessThreshold {
    pub thresholdmodel_BGR: MFloat,
    pub thresholdmodel_IR: MFloat,
}
#[test]
fn bindgen_test_layout_ASF_LivenessThreshold() {
    assert_eq!(
        ::std::mem::size_of::<ASF_LivenessThreshold>(),
        8usize,
        concat!("Size of: ", stringify!(ASF_LivenessThreshold))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_LivenessThreshold>(),
        4usize,
        concat!("Alignment of ", stringify!(ASF_LivenessThreshold))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASF_LivenessThreshold>())).thresholdmodel_BGR as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_LivenessThreshold),
            "::",
            stringify!(thresholdmodel_BGR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASF_LivenessThreshold>())).thresholdmodel_IR as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_LivenessThreshold),
            "::",
            stringify!(thresholdmodel_IR)
        )
    );
}
pub type LPASF_LivenessThreshold = *mut ASF_LivenessThreshold;
extern "C" {
    /// 取值范围[0-1]内部默认数值RGB-0.75，IR-0.7， 用户可以根据实际需求，设置不同的阈值
    pub fn ASFSetLivenessParam(hEngine: MHandle, threshold: LPASF_LivenessThreshold) -> MRESULT;
}
extern "C" {
    /// 年龄/性别/3D角度（该接口仅支持RGB图像），最多支持4张人脸信息检测，超过部分返回未知
    /// RGB活体仅支持单人脸检测
    /// 该接口不支持检测IR活体
    pub fn ASFProcess(
        hEngine: MHandle,
        width: MInt32,
        height: MInt32,
        format: MInt32,
        imgData: *mut MUInt8,
        detectedFaces: LPASF_MultiFaceInfo,
        combinedMask: MInt32,
    ) -> MRESULT;
}
extern "C" {
    /// 该接口目前仅支持单人脸IR活体检测（不支持年龄、性别、3D角度的检测），默认取第一张人脸
    pub fn ASFProcess_IR(
        hEngine: MHandle,
        width: MInt32,
        height: MInt32,
        format: MInt32,
        imgData: *mut MUInt8,
        detectedFaces: LPASF_MultiFaceInfo,
        combinedMask: MInt32,
    ) -> MRESULT;
}
extern "C" {
    /// 销毁引擎
    pub fn ASFUninitEngine(hEngine: MHandle) -> MRESULT;
}
extern "C" {
    /// 获取版本信息
    pub fn ASFGetVersion(hEngine: MHandle) -> *const ASF_VERSION;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_FaceFeature {
    pub feature: *mut MByte,
    pub featureSize: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_FaceFeature() {
    assert_eq!(
        ::std::mem::size_of::<ASF_FaceFeature>(),
        16usize,
        concat!("Size of: ", stringify!(ASF_FaceFeature))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_FaceFeature>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_FaceFeature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_FaceFeature>())).feature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_FaceFeature),
            "::",
            stringify!(feature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_FaceFeature>())).featureSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_FaceFeature),
            "::",
            stringify!(featureSize)
        )
    );
}
pub type LPASF_FaceFeature = *mut ASF_FaceFeature;
extern "C" {
    /// 单人脸特征提取
    pub fn ASFFaceFeatureExtract(
        hEngine: MHandle,
        width: MInt32,
        height: MInt32,
        format: MInt32,
        imgData: *mut MUInt8,
        faceInfo: LPASF_SingleFaceInfo,
        feature: LPASF_FaceFeature,
    ) -> MRESULT;
}
extern "C" {
    /// 人脸特征比对
    pub fn ASFFaceFeatureCompare(
        hEngine: MHandle,
        feature1: LPASF_FaceFeature,
        feature2: LPASF_FaceFeature,
        confidenceLevel: *mut MFloat,
    ) -> MRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_AgeInfo {
    pub ageArray: *mut MInt32,
    pub num: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_AgeInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_AgeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(ASF_AgeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_AgeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_AgeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_AgeInfo>())).ageArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_AgeInfo),
            "::",
            stringify!(ageArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_AgeInfo>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_AgeInfo),
            "::",
            stringify!(num)
        )
    );
}
pub type LPASF_AgeInfo = *mut ASF_AgeInfo;
extern "C" {
    /// 获取年龄信息
    pub fn ASFGetAge(hEngine: MHandle, ageInfo: LPASF_AgeInfo) -> MRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_GenderInfo {
    pub genderArray: *mut MInt32,
    pub num: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_GenderInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_GenderInfo>(),
        16usize,
        concat!("Size of: ", stringify!(ASF_GenderInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_GenderInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_GenderInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_GenderInfo>())).genderArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_GenderInfo),
            "::",
            stringify!(genderArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_GenderInfo>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_GenderInfo),
            "::",
            stringify!(num)
        )
    );
}
pub type LPASF_GenderInfo = *mut ASF_GenderInfo;
extern "C" {
    /// 获取性别信息
    pub fn ASFGetGender(hEngine: MHandle, genderInfo: LPASF_GenderInfo) -> MRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_Face3DAngle {
    pub roll: *mut MFloat,
    pub yaw: *mut MFloat,
    pub pitch: *mut MFloat,
    pub status: *mut MInt32,
    pub num: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_Face3DAngle() {
    assert_eq!(
        ::std::mem::size_of::<ASF_Face3DAngle>(),
        40usize,
        concat!("Size of: ", stringify!(ASF_Face3DAngle))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_Face3DAngle>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_Face3DAngle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_Face3DAngle>())).roll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_Face3DAngle),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_Face3DAngle>())).yaw as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_Face3DAngle),
            "::",
            stringify!(yaw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_Face3DAngle>())).pitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_Face3DAngle),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_Face3DAngle>())).status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_Face3DAngle),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_Face3DAngle>())).num as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_Face3DAngle),
            "::",
            stringify!(num)
        )
    );
}
pub type LPASF_Face3DAngle = *mut ASF_Face3DAngle;
extern "C" {
    /// 获取3D角度信息
    pub fn ASFGetFace3DAngle(hEngine: MHandle, p3DAngleInfo: LPASF_Face3DAngle) -> MRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASF_LivenessInfo {
    pub isLive: *mut MInt32,
    pub num: MInt32,
}
#[test]
fn bindgen_test_layout_ASF_LivenessInfo() {
    assert_eq!(
        ::std::mem::size_of::<ASF_LivenessInfo>(),
        16usize,
        concat!("Size of: ", stringify!(ASF_LivenessInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ASF_LivenessInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ASF_LivenessInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_LivenessInfo>())).isLive as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_LivenessInfo),
            "::",
            stringify!(isLive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASF_LivenessInfo>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASF_LivenessInfo),
            "::",
            stringify!(num)
        )
    );
}
pub type LPASF_LivenessInfo = *mut ASF_LivenessInfo;
extern "C" {
    /// 获取RGB活体结果
    pub fn ASFGetLivenessScore(hEngine: MHandle, livenessInfo: LPASF_LivenessInfo) -> MRESULT;
}
extern "C" {
    /// 获取IR活体结果
    pub fn ASFGetLivenessScore_IR(hEngine: MHandle, irLivenessInfo: LPASF_LivenessInfo) -> MRESULT;
}
